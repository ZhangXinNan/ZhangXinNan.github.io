<!DOCTYPE html>
<html lang="ch">
<head>
        <meta charset="utf-8" />
        <title>人工神经网络</title>
        <link rel="stylesheet" href="http://zhangxinnan.github.io/theme/css/main.css" />

        <!--[if IE]>
            <script src="https://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
        <![endif]-->
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="http://zhangxinnan.github.io/">WilledIt </a></h1>
                <nav><ul>
                    <li class="active"><a href="http://zhangxinnan.github.io/category/deeplearning.html">DeepLearning</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="http://zhangxinnan.github.io/ArtificialNeuralNetwork.html" rel="bookmark"
           title="Permalink to 人工神经网络">人工神经网络</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-06-23T00:00:00+08:00">
                Published: 四 23 六月 2016
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="http://zhangxinnan.github.io/author/zhangxinnan.html">ZhangXinNan</a>
        </address>
<p>In <a href="http://zhangxinnan.github.io/category/deeplearning.html">DeepLearning</a>.</p>
<p>tags: <a href="http://zhangxinnan.github.io/tag/neuralnetwork.html">NeuralNetwork</a> </p>
</footer><!-- /.post-info -->      <h3>1 人工神经网络简介</h3>
<h4>生物学动机</h4>
<p>人工神经网络ANN的研究一定程度上受到了生物学的启发，生物的学习系统由相互连接的神经元（neuron）组成的异常复杂的网格。而人工神经网络由一系列简单的单元相互密集连接构成的，其中每一个单元有一定数量的实值输入，并产生单一的实数值输出。据估计人类的大脑是由大约<span class="math">\(10^{11}\)</span>次方个神经元相互连接组成的密集网络，平均每个神经元与其他<span class="math">\(10^4\)</span>个神经元相连。神经元的活性通常被通向其他神经元的连接激活或抑制。</p>
<h3>2 神经网络表示</h3>
<p>1993年的ALVINN系统是ANN学习的一个典型实例，这个系统使用一个学习到的ANN以正常的速度在高速公路上驾驶汽车。ANN的输入是一个30*32像素的网格，像素的亮度来自一个安装在车辆上的前向摄像机。ANN的输出是车辆行驶的方向。
<img alt="ALVINN" src="images/ALVINN.jpg" /></p>
<h3>3 适合神经网络学习的问题</h3>
<ul>
<li>实例是用很多属性-值表示的</li>
<li>目标函数的输出可能是离散值、实数值或者由若干实数属性或者离散属性组成的向量</li>
<li>训练数据可能包含错误</li>
<li>可容忍长时间的训练</li>
<li>可能需要快速求出目标函数值</li>
<li>人类能否理解学到的目标函数不是重要的。</li>
</ul>
<h3>4 感知器</h3>
<p>感知器以一个实数值向量作为输入，计算这些输入的线性组合 ，然后如果结果大于某个阈值，就输出1，否则输出-1。
</p>
<div class="math">$$o(x_1, x_2,...,x_n) = \begin{equation}
\begin{cases}
1  \quad  if (w_0 + w_1x_1+...+w_nx_n)\\
-1  \quad otherwise
\end{cases}
\end{equation} $$</div>
<p>
假设输入空间（特征空间）是<span class="math">\(X  \subseteq R^n\)</span>，输出空间是<span class="math">\(Y = \{-1, +1\}\)</span>。输入<span class="math">\(x \subseteq X\)</span>是实例的特征向量，对应于输入空间的点；输出<span class="math">\(y \subseteq Y\)</span>表示实例的类别。由输入空间到输出空间的如下函数称为感知机：
</p>
<div class="math">$$f(x)=sign(w \cdot x + b)$$</div>
<p>
其中w b称为感知机的模型参数，w叫做权值（weight）或者权值向量（weight vector），b叫做偏置（bias）。<span class="math">\(w\cdot x\)</span>表示w和x的内积。sign是符号函数：
</p>
<div class="math">$$sign(x) = \begin{equation}\begin{cases} +1, x &gt;= 0 \\ -1 , x &lt;= 0 \end{cases}\end{equation}$$</div>
<p>
感知机是一种线性分类模型，它的假设空间是定义在特征空间中的所有线性分类模型。
感知机有如下几何解释：线性方程</p>
<div class="math">$$w \cdot x + b = 0$$</div>
<p>
对应于特征空间的一个超平面S。这个超平面把特征空间划分成两部分，位于两部分的点分别被分为正负两类。</p>
<h3>5 多层网络和反向传播算法</h3>
<h4>5.1 可微阈值单元</h4>
<ul>
<li>多个线性单元的连接仍然是产生的是线性函数，而我们更选择选择能够表征非线性函数的网络。</li>
<li>感知器单元的不连续阈值使它不可微，所以不适合梯度下降算法。</li>
</ul>
<p>我们需要的是这样一种单元，它的输出是输入的非线性函数，并且输出是输入的可微函数。sigmoid单元是一种非常类似感知器的单元，并且它基于一个平滑的可微阈值函数。
</p>
<div class="math">$$o = \sigma(w * x)$$</div>
<div class="math">$$\sigma(y)=\frac1{1+e^{-y}}$$</div>
<ul>
<li><span class="math">\(\sigma\)</span>经常被称为Sigmoid函数或者logistic函数。它的输出范围是0到1，随输入单调递增。因为这个函数把非常大的输入值映射到一个小范围的输出，它经常被称为Sigmoid单元的挤压函数。</li>
<li>sigmoid函数的导数很容易用它的输出表示。
<div class="math">$$\frac{\mathrm{d}  \sigma(y)}{\mathrm{d} y} = \sigma(y) * (1 - \sigma(y))$$</div>
</li>
</ul>
<h4>5.2 反向传播算法</h4>
<p>对于一系列确定的单元互联形成的多层网络，反向传播算法可用来学习这个网络的权值。它采用梯度下降方法试图最小化网络输出值与目标值之间的误差平方。
</p>
<div class="math">$$E(w) = \frac1{2}\sum_{d\in{D}}\sum_{k\in{outputs}}(t_{kd}-o_{kd})^2$$</div>
<p>
其中outputs是网络输出单元的集合，<span class="math">\(t_{kd}\)</span>和<span class="math">\(o_{kd}\)</span>是与训练样例<span class="math">\(d\)</span>和第<span class="math">\(k\)</span>个输出单元相关的输出值。
   反向传播算法面临的学习问题是搜索一个巨大的假设空间，这个空间由网络中所有单元的所有可能的权值定义。
   在多层网络中，误差曲面可能有多个局部极小值。梯度下降仅能保证收敛到局部极小值，而未必得到全局最小的误差。
   包含两层sigmoid单元的前馈网络的反向传播算法：</p>
<hr />
<ul>
<li>创建具有<span class="math">\(n_{in}\)</span>个输入，<span class="math">\(n_{hidden}\)</span>个隐藏单元，<span class="math">\(n_{out}\)</span>个输出单元的网络。</li>
<li>初始化所有的网络权值为小的随机值（-0.05-0.05）</li>
<li>在遇到终止条件前：
  对于训练样例train_sample中的每一个(x, t)（x网络输入值的向量，t网络输出值的向量）</li>
<li>把实例<span class="math">\(x\)</span>输入网络，并计算网络中每个单元<span class="math">\(u\)</span>的输出<span class="math">\(o\)</span></li>
<li>对于网络的每一个输出单元<span class="math">\(k\)</span>，计算它的误差项<span class="math">\(\delta_k\)</span> <div class="math">$$\delta_k = o_k(1-o_k)(t_k-o_k)$$</div>
</li>
<li>对于网络的每个隐藏单元<span class="math">\(h\)</span>，计算它的误差<span class="math">\(\delta_h\)</span> <div class="math">$$\delta_h = o_h(1-o_h)\sum_{k\in outputs}w_{kh}\delta_k$$</div>
</li>
<li>更新每个网络权值<span class="math">\(w_{ji}\)</span> <div class="math">$$w_{ji}=w_{ji} + \Delta w_{ji} $$</div>
其中<span class="math">\(\delta_{ji}=\eta \delta_j x_{ji}\)</span></li>
</ul>
<hr />
<p>梯度下降更新法则依照以下三者来更新每一个权： 学习速率<span class="math">\(\eta\)</span>，该权值涉及到输入<span class="math">\(x_{ji}\)</span>，这个单元输出的误差。
为了直观的理解它，先考虑网络的每一个输出单元k的<span class="math">\(\delta_k\)</span>是怎样计算的。<span class="math">\(\delta_k\)</span>与delta法则中的<span class="math">\((t_k-o_k)\)</span>相似，但乘上了挤压函数的导数<span class="math">\(o_k(1-o_k)\)</span>。
每个隐藏单元h的<span class="math">\(\delta_h\)</span>具有相似的形式。因为训练样例仅对网络的输出提供了目标值，所有缺少直接的目标值来计算隐藏单元的误差值。因此采取下边间接办法计算隐藏单元的误差项：对受隐藏单元h影响的每一个单元的误差<span class="math">\(\delta_h\)</span>进行加权求和，每个误差<span class="math">\(\delta_k\)</span>权值为<span class="math">\(w_{kh}\)</span>，<span class="math">\(w_{kh}\)</span>就是从隐藏单元h到输出单元k的权值。这个权值刻画了隐藏单元h对于输出单元k的误差应“负责”的程度。</p>
<h4>5.3 反向传播算法的推导</h4>
<p>随机的梯度下降算法迭代处理训练样例，每次处理一个。对于每个训练样例<span class="math">\(d\)</span>，利用这个样例的误差<span class="math">\(E_d\)</span>的梯度修改权值。换句话说，对于每一个训练样例<span class="math">\(d\)</span>，每个权<span class="math">\(w_{ji}\)</span>增加<span class="math">\(\Delta w_{ji}\)</span>。
</p>
<div class="math">$$\Delta w_{ji} = -\eta\frac{\partial E_d}{\partial w_{ji}}$$</div>
<div class="math">$$E_d(w) = \frac1{2}\sum_{k\in{outputs}}(t_k - o_k)^2$$</div>
<ul>
<li><span class="math">\(x_{ji}\)</span> = 单元<span class="math">\(j\)</span>的第<span class="math">\(i\)</span>个输入</li>
<li><span class="math">\(w_{ji}\)</span> = 与单元<span class="math">\(j\)</span>的第<span class="math">\(i\)</span>个输入相关联的权值</li>
<li><span class="math">\(net_j = \sum{w_{ji}x_{ji}}\)</span></li>
<li><span class="math">\(o_j\)</span> = 单元<span class="math">\(j\)</span>计算出的输出</li>
<li><span class="math">\(t_j\)</span> = 单元<span class="math">\(j\)</span>的目标输出</li>
<li><span class="math">\(\sigma\)</span> = sigmoid函数</li>
<li><span class="math">\(outputs =\)</span>网络最后一层的单元的集合</li>
<li><span class="math">\(Downstream(j)\)</span>单元的直接输入中包含单元<span class="math">\(j\)</span> 的输出的单元的集合</li>
</ul>
<p>权值<span class="math">\(w_{ji}\)</span>仅能通过<span class="math">\(net_j\)</span>影响网络的其他部分。所以我们用链式规则得到 ：
</p>
<div class="math">$$\frac{\partial E_d}{\partial w_{ji}} = \frac{\partial E_d}{\partial net_j}\frac{\partial net_j}{\partial  w_{ji}} = \frac{\partial E_d}{\partial net_j} x_{ji}$$</div>
<p>剩下的任务就是为$\frac{\partial E_d}{\partial net_j} $导出一个方便的表达式。</p>
<ol>
<li>输出单元的权值训练法则
<div class="math">$$\frac{\partial E_d}{\partial net_j} = \frac{\partial E_d}{\partial o_j} \frac{\partial o_j}{\partial net_j}$$</div>
</li>
</ol>
<p>（1） 考虑公式中的第一项（<span class="math">\(\frac{\partial E_d}{\partial o_j} $）
<div class="math">$$\frac {\partial E_d}{\partial o_j} = \frac {\partial}{o_j} \frac 1 2 \sum_{k \in outputs} (t_k - o_k)^2$$</div>
除了当\)</span>k = j <span class="math">\(时，所有输出单元k的导数\)</span>\frac {\partial} {\partial o_j} (t_k-o_k)^2<span class="math">\(为0。
所以我们不必对多个输出单元求和，只需设\)</span>k=j$
</p>
<div class="math">$$ \begin{split}
\frac{\partial E_d}{\partial o_j} &amp;= \frac{\partial }{\partial o_j}\frac12(t_j-o_j)^2 \\
&amp;= (t_j-o_j)\frac{\partial(t_j-o_j)}{\partial o_j} \\
&amp;= -(t_j-o_j)\end{split} $$</div>
<p>（2） 考虑公式中的第二项（<span class="math">\(\frac{\partial o_j}{\partial net_j}\)</span>）
既然<span class="math">\(o_j=\sigma(net_j)\)</span>，导数<span class="math">\(\frac{\partial o_j}{\partial net_j}\)</span>就是sigmoid函数的导数。
</p>
<div class="math">$$\frac {\partial o_j}{\partial net_j} = \frac{\partial\sigma(net_j)}{\partial net_j} = o_j(1-o_j)$$</div>
<p>由上可得：
</p>
<div class="math">$$\frac{\partial{E_d}}{\partial{net_j}}=-(t_j-o_j)o_j(1-o_j)$$</div>
<p>
输出单元的随机梯度下降法则：
</p>
<div class="math">$$\Delta w_{ji}=\eta\frac{\partial E_d}{\partial w_{ji}}=\eta(t_j-o_j)o_j(1-o_j)x_{ji}$$</div>
<p>
2. 隐藏单元的权值训练法则
对于网络中的内部单元或者隐藏单元的情况，推导<span class="math">\(w_{ji}\)</span>必须考虑<span class="math">\(w_{ji}\)</span>间接地影响网络输出，从而影响<span class="math">\(E_d\)</span>。
<span class="math">\(net_j\)</span>只能通过 <span class="math">\(Downstream(j)\)</span>中的单元影响网络输出，再影响<span class="math">\(E_d\)</span>。
</p>
<div class="math">$$\begin{split}\frac{\partial E_d}{\partial net_j} &amp;=\sum_{k\in Downstream(j)}\frac{\partial E_d}{\partial net_k}\frac{net_k}{net_j} \\&amp;=\sum_{k\in Downstream(j)}-\delta_k\frac{net_k}{net_j}\\&amp;=\sum_{k\in Downstream(j)}-\delta_k\frac{\partial net_k}{\partial o_j}\frac {\partial o_j}{\partial net_j}\\&amp;=\sum_{k\in Downstream(j)}-\delta_k w_{kj}\frac {\partial o_j}{\partial net_j}\\&amp;=\sum_{k\in Downstream(j)}-\delta_k w_{kj}o_j(1-o_j)\end{split}$$</div>
<p>
用<span class="math">\(\delta_j\)</span>表示<span class="math">\(-\frac{\partial E_d}{\partial net_j}\)</span>，得到：
</p>
<div class="math">$$\delta_j=o_j(1-o_j)\sum_k\in Donwstream(j)\delta_k w_{kj}$$</div>
<div class="math">$$\Delta w_{ji}=\eta \delta_j x_{ji}$$</div>
<h4>5.4 代码实践</h4>
<div class="highlight"><pre><span></span><span class="c1">//#include &quot;load_dataset.hpp&quot;</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;sys/stat.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>

<span class="cp">#include</span> <span class="cpf">&lt;opencv2/opencv.hpp&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">cv</span><span class="p">;</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">uint32_t</span> <span class="nf">swap_endian</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">val</span> <span class="o">=</span> <span class="p">((</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF00FF00</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF00FF</span><span class="p">);</span>
   <span class="k">return</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">val</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">str2Mat</span><span class="p">(</span><span class="kt">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pixels</span><span class="p">,</span> <span class="kt">const</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">const</span> <span class="kt">int</span> <span class="n">col</span><span class="p">){</span>
   <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">m</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">CV_8UC1</span><span class="p">);</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">row</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">memcpy</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">m</span><span class="p">.</span><span class="nf">step</span><span class="p">,</span> <span class="n">pixels</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">col</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">m</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">convert_dataset</span><span class="p">(</span><span class="kt">const</span> <span class="kt">string</span> <span class="o">&amp;</span><span class="n">image_filename</span><span class="p">,</span> <span class="kt">const</span> <span class="kt">string</span> <span class="o">&amp;</span><span class="n">label_filename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vvMat</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">vvMat</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
   <span class="c1">// Open files</span>
   <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">image_file</span><span class="p">(</span><span class="n">image_filename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">ifstream</span> <span class="n">label_file</span><span class="p">(</span><span class="n">label_filename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">in</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ios</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
   <span class="c1">//CHECK(image_file) &lt;&lt; &quot;Unable to open file &quot; &lt;&lt; image_filename;</span>
   <span class="c1">//CHECK(label_file) &lt;&lt; &quot;Unable to open file &quot; &lt;&lt; label_filename;</span>
   <span class="c1">// Read the magic and the meta data</span>
   <span class="kt">uint32_t</span> <span class="n">magic</span><span class="p">;</span>
   <span class="kt">uint32_t</span> <span class="n">num_items</span><span class="p">;</span>
   <span class="kt">uint32_t</span> <span class="n">num_labels</span><span class="p">;</span>
   <span class="kt">uint32_t</span> <span class="n">rows</span><span class="p">;</span>
   <span class="kt">uint32_t</span> <span class="n">cols</span><span class="p">;</span>

   <span class="n">image_file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">magic</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
   <span class="n">magic</span> <span class="o">=</span> <span class="n">swap_endian</span><span class="p">(</span><span class="n">magic</span><span class="p">);</span>
   <span class="c1">//CHECK_EQ(magic, 2051) &lt;&lt; &quot;Incorrect image file magic.&quot;;</span>
   <span class="n">label_file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">magic</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
   <span class="n">magic</span> <span class="o">=</span> <span class="n">swap_endian</span><span class="p">(</span><span class="n">magic</span><span class="p">);</span>
   <span class="c1">//CHECK_EQ(magic, 2049) &lt;&lt; &quot;Incorrect label file magic.&quot;;</span>
   <span class="n">image_file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_items</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
   <span class="n">num_items</span> <span class="o">=</span> <span class="n">swap_endian</span><span class="p">(</span><span class="n">num_items</span><span class="p">);</span>
   <span class="n">label_file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">num_labels</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
   <span class="n">num_labels</span> <span class="o">=</span> <span class="n">swap_endian</span><span class="p">(</span><span class="n">num_labels</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;num_items &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">num_items</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, num_labels &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">num_labels</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
   <span class="c1">//CHECK_EQ(num_items, num_labels);</span>
   <span class="n">image_file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rows</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
   <span class="n">rows</span> <span class="o">=</span> <span class="n">swap_endian</span><span class="p">(</span><span class="n">rows</span><span class="p">);</span>
   <span class="n">image_file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cols</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
   <span class="n">cols</span> <span class="o">=</span> <span class="n">swap_endian</span><span class="p">(</span><span class="n">cols</span><span class="p">);</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;rows &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">rows</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, cols &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cols</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

   <span class="c1">// Storing to db</span>
   <span class="kt">char</span> <span class="n">label</span><span class="p">;</span>
   <span class="kt">char</span><span class="o">*</span> <span class="n">pixels</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">];</span>

   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">item_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">item_id</span> <span class="o">&lt;</span> <span class="n">num_items</span><span class="p">;</span> <span class="o">++</span><span class="n">item_id</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">image_file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">);</span>
       <span class="n">label_file</span><span class="p">.</span><span class="nf">read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">label</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
       <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">img</span> <span class="o">=</span> <span class="n">str2Mat</span><span class="p">(</span><span class="n">pixels</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
       <span class="c1">//std::cout &lt;&lt; int(label) &lt;&lt; std::endl;</span>
       <span class="c1">//print_mat(img);</span>
       <span class="c1">//string winname = &quot;0&quot;;</span>
       <span class="c1">//winname[0] += label;</span>
       <span class="c1">//imshow(winname, img);</span>
       <span class="c1">//waitKey();</span>
       <span class="c1">//destroyAllWindows();</span>
       <span class="n">vvMat</span><span class="p">[</span><span class="n">label</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">img</span><span class="p">);</span>
       <span class="c1">//break;</span>
   <span class="p">}</span>

   <span class="k">delete</span><span class="p">[]</span> <span class="n">pixels</span><span class="p">;</span>
<span class="p">}</span>



<span class="kr">inline</span> <span class="kt">double</span> <span class="n">sigmoid</span><span class="p">(</span><span class="kt">double</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">//sigmoid函数的导数</span>
<span class="kr">inline</span> <span class="kt">double</span> <span class="n">sigmoid_prime</span><span class="p">(</span><span class="kt">double</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">));</span>
<span class="p">}</span>


<span class="kt">const</span> <span class="kt">int</span> <span class="n">n_in</span>      <span class="o">=</span> <span class="mi">784</span><span class="p">;</span>
<span class="kt">const</span> <span class="kt">int</span> <span class="n">n_hidden</span>  <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="kt">const</span> <span class="kt">int</span> <span class="n">n_out</span>     <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>



<span class="kt">double</span> <span class="n">w1</span><span class="p">[</span><span class="n">n_hidden</span><span class="p">][</span><span class="n">n_in</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">w2</span><span class="p">[</span><span class="n">n_out</span><span class="p">][</span><span class="n">n_hidden</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">b1</span><span class="p">[</span><span class="n">n_hidden</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">b2</span><span class="p">[</span><span class="n">n_out</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">delta_w1</span><span class="p">[</span><span class="n">n_hidden</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">delta_w2</span><span class="p">[</span><span class="n">n_out</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">delta_b1</span><span class="p">[</span><span class="n">n_hidden</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">delta_b2</span><span class="p">[</span><span class="n">n_out</span><span class="p">];</span>
<span class="kt">double</span> <span class="n">eta</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">init_wb</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">init_delta</span><span class="p">();</span>
<span class="kt">double</span> <span class="nf">evaluate</span><span class="p">(</span><span class="kt">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">vvMatTest</span><span class="p">,</span> <span class="kt">const</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">forward</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">h</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">Mat8uc1_darr</span><span class="p">(</span><span class="kt">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">arr</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">print_mat</span><span class="p">(</span><span class="kt">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print_array</span><span class="p">(</span><span class="kt">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">sgd</span><span class="p">(</span><span class="kt">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">vvMatTrain</span><span class="p">,</span> <span class="kt">const</span> <span class="kt">int</span> <span class="n">numTrain</span><span class="p">,</span> <span class="kt">const</span> <span class="kt">int</span> <span class="n">beginIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="kt">string</span> <span class="n">data_path</span> <span class="o">=</span> <span class="s">&quot;/Users/zhangxin/datas/mnist/&quot;</span><span class="p">;</span>
   <span class="kt">string</span> <span class="n">images_test</span> <span class="o">=</span> <span class="s">&quot;t10k-images-idx3-ubyte&quot;</span><span class="p">;</span>
   <span class="kt">string</span> <span class="n">labels_test</span> <span class="o">=</span> <span class="s">&quot;t10k-labels-idx1-ubyte&quot;</span><span class="p">;</span>
   <span class="kt">string</span> <span class="n">images_train</span> <span class="o">=</span> <span class="s">&quot;train-images-idx3-ubyte&quot;</span><span class="p">;</span>
   <span class="kt">string</span> <span class="n">labels_train</span> <span class="o">=</span> <span class="s">&quot;train-labels-idx1-ubyte&quot;</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">vvMat</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">vvMatTest</span><span class="p">;</span>
   <span class="n">convert_dataset</span><span class="p">(</span><span class="n">data_path</span> <span class="o">+</span> <span class="n">images_test</span><span class="p">,</span>  <span class="n">data_path</span> <span class="o">+</span> <span class="n">labels_test</span><span class="p">,</span> <span class="n">vvMatTest</span><span class="p">);</span>
   <span class="n">convert_dataset</span><span class="p">(</span><span class="n">data_path</span> <span class="o">+</span> <span class="n">images_train</span><span class="p">,</span> <span class="n">data_path</span> <span class="o">+</span> <span class="n">labels_train</span><span class="p">,</span> <span class="n">vvMat</span><span class="p">);</span>

   <span class="n">init_wb</span><span class="p">();</span>
   <span class="n">evaluate</span><span class="p">(</span><span class="n">vvMatTest</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>

   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%4d --------</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
       <span class="n">sgd</span><span class="p">(</span><span class="n">vvMat</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>
       <span class="n">evaluate</span><span class="p">(</span><span class="n">vvMatTest</span><span class="p">,</span> <span class="mi">2000</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="c1">//evaluate(vvMatTest, 1000);</span>

   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">sgd</span><span class="p">(</span><span class="kt">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">vvMatTrain</span><span class="p">,</span> <span class="kt">const</span> <span class="kt">int</span> <span class="n">numTrain</span><span class="p">,</span> <span class="kt">const</span> <span class="kt">int</span> <span class="n">beginIndex</span><span class="p">){</span>
   <span class="n">init_delta</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numTrain</span> <span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_out</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
           <span class="kt">double</span> <span class="n">y</span><span class="p">[</span><span class="n">n_out</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">};</span>
           <span class="kt">double</span> <span class="n">x</span><span class="p">[</span><span class="n">n_in</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">};</span>
           <span class="kt">double</span> <span class="n">h</span><span class="p">[</span><span class="n">n_hidden</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">};</span>
           <span class="n">Mat8uc1_darr</span><span class="p">(</span><span class="n">vvMatTrain</span><span class="p">[</span><span class="n">i</span><span class="p">][(</span><span class="n">beginIndex</span> <span class="o">+</span> <span class="n">j</span><span class="p">)</span> <span class="o">%</span> <span class="n">vvMatTrain</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">size</span><span class="p">()],</span> <span class="n">x</span><span class="p">);</span>
           <span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

           <span class="kt">double</span> <span class="n">t</span><span class="p">[</span><span class="n">n_out</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">};</span>
           <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

           <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n_out</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
               <span class="n">delta_w2</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_b2</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">m</span><span class="p">]);</span>
               <span class="n">b2</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">eta</span> <span class="o">*</span> <span class="n">delta_b2</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>

               <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">n_hidden</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                   <span class="n">w2</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">eta</span> <span class="o">*</span> <span class="n">delta_w2</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
               <span class="p">}</span>
           <span class="p">}</span>

           <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n_hidden</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
               <span class="n">delta_b1</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
               <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n_out</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                   <span class="n">delta_b1</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">w2</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">delta_w2</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
               <span class="p">}</span>
               <span class="n">delta_w1</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_b1</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_b1</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">h</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">m</span><span class="p">]);</span>
               <span class="n">b1</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">+=</span> <span class="n">eta</span> <span class="o">*</span> <span class="n">delta_b1</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>

               <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">n_in</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                   <span class="n">w1</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">eta</span> <span class="o">*</span> <span class="n">delta_w1</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
               <span class="p">}</span>

           <span class="p">}</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>


<span class="kt">double</span> <span class="nf">evaluate</span><span class="p">(</span><span class="kt">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Mat</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">vvMatTest</span><span class="p">,</span> <span class="kt">const</span> <span class="kt">int</span> <span class="n">num</span><span class="p">){</span>
   <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">sum_right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec_sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec_sum_right</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
   <span class="kt">int</span> <span class="n">result</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">];</span>
   <span class="n">memset</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">);</span>

   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_out</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vvMatTest</span><span class="p">.</span><span class="nf">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">vvMatTest</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span><span class="c1">//</span>
           <span class="kt">double</span> <span class="n">x</span><span class="p">[</span><span class="n">n_in</span><span class="p">];</span>
           <span class="kt">double</span> <span class="n">y</span><span class="p">[</span><span class="n">n_out</span><span class="p">];</span>
           <span class="kt">double</span> <span class="n">h</span><span class="p">[</span><span class="n">n_hidden</span><span class="p">];</span>
           <span class="kt">const</span> <span class="n">Mat</span> <span class="o">&amp;</span><span class="n">img</span> <span class="o">=</span> <span class="n">vvMatTest</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

           <span class="n">Mat8uc1_darr</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
<span class="c1">//            print_mat(img);</span>
<span class="c1">//            print_array(x, img.rows, img.cols);</span>
<span class="c1">//            imshow(&quot;00&quot;, img);</span>
<span class="c1">//            waitKey();</span>
<span class="c1">//            continue;</span>

           <span class="n">forward</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
           <span class="kt">int</span> <span class="n">predict_label</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
           <span class="kt">double</span> <span class="n">predict_f</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="c1">//y.at&lt;double&gt;(0, 0);</span>
           <span class="c1">//printf(&quot;%2d %4d :[ 0] %6.3f, &quot;, i, j, predict_f);</span>
           <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n_out</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
               <span class="kt">double</span> <span class="n">f</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">];</span><span class="c1">//y.at&lt;double&gt;(0, k);</span>
               <span class="c1">//printf(&quot;%d %6.3f, &quot;, k, f);</span>
               <span class="k">if</span> <span class="p">(</span><span class="n">f</span>  <span class="o">&gt;</span> <span class="n">predict_f</span> <span class="p">)</span> <span class="p">{</span>
                   <span class="n">predict_f</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>
                   <span class="n">predict_label</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
               <span class="p">}</span>
           <span class="p">}</span>
           <span class="c1">//printf(&quot; predict : %d %6.3f\n&quot;, predict_label, predict_f);</span>

           <span class="n">vec_sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
           <span class="n">sum</span><span class="o">++</span><span class="p">;</span>
           <span class="k">if</span> <span class="p">(</span><span class="n">predict_label</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
               <span class="n">sum_right</span><span class="o">++</span><span class="p">;</span>
               <span class="n">vec_sum_right</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
           <span class="p">}</span>
           <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">predict_label</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
       <span class="p">}</span>
   <span class="p">}</span>
   <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;sum : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, sum_right : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">sum_right</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_out</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">printf</span><span class="p">(</span><span class="s">&quot; [%d] [%4d %4d] &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">vec_sum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vec_sum_right</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_out</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">printf</span> <span class="p">(</span><span class="s">&quot;%4d &quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
       <span class="p">}</span>
       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="n">sum_right</span> <span class="o">/</span> <span class="kt">double</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">forward</span><span class="p">(</span><span class="kt">double</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span><span class="o">*</span> <span class="n">h</span><span class="p">){</span>

   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_hidden</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_in</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">w1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>

       <span class="p">}</span>
       <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
   <span class="p">}</span>

   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_out</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_hidden</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">h</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">w2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
       <span class="p">}</span>
       <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
   <span class="p">}</span>

<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Mat8uc1_darr</span><span class="p">(</span><span class="kt">const</span> <span class="n">Mat</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">,</span> <span class="kt">double</span> <span class="o">*</span><span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">arr</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">m</span><span class="p">.</span><span class="n">cols</span> <span class="o">+</span> <span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">uchar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span><span class="p">;</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">init_delta</span><span class="p">(){</span>
   <span class="n">memset</span><span class="p">(</span><span class="n">delta_w1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_hidden</span><span class="p">);</span>
   <span class="n">memset</span><span class="p">(</span><span class="n">delta_w2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_out</span><span class="p">);</span>
   <span class="n">memset</span><span class="p">(</span><span class="n">delta_b1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_hidden</span><span class="p">);</span>
   <span class="n">memset</span><span class="p">(</span><span class="n">delta_b2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">*</span> <span class="n">n_out</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">void</span> <span class="nf">init_wb</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">srand</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">std</span><span class="o">::</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span> <span class="c1">// use current time as seed for random generator</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; init w1 : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_hidden</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; w1[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_in</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">w1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span><span class="o">/</span><span class="kt">double</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">;</span>
           <span class="n">w1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.1</span><span class="p">;</span>
           <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%6.3f &quot;</span><span class="p">,</span> <span class="n">w1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
       <span class="p">}</span>
       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; init w2 : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_out</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; w1[&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;]&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_hidden</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">w2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span><span class="o">/</span><span class="kt">double</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">;</span>
           <span class="n">w2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.1</span><span class="p">;</span>
           <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%6.3f &quot;</span><span class="p">,</span> <span class="n">w2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
       <span class="p">}</span>
       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="p">}</span>
   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;init b1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_hidden</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">b1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="kt">double</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">;</span>
       <span class="n">b1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.1</span><span class="p">;</span>
       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%6.3f &quot;</span><span class="p">,</span> <span class="n">b1</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
   <span class="p">}</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

   <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;init b2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_out</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">b2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">rand</span><span class="p">()</span> <span class="o">/</span> <span class="kt">double</span><span class="p">(</span><span class="n">RAND_MAX</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">;</span>
       <span class="n">b2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.2</span><span class="p">;</span>
       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%6.3f &quot;</span><span class="p">,</span> <span class="n">b2</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
   <span class="p">}</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

<span class="p">}</span>



<span class="kt">void</span> <span class="nf">print_mat</span><span class="p">(</span><span class="kt">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">rows</span><span class="p">;</span> <span class="n">y</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[%4d] &quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
       <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">cols</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">switch</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">type</span><span class="p">()){</span>
               <span class="k">case</span> <span class="nl">CV_8UC1</span><span class="p">:</span>
                   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%3d &quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">y</span> <span class="o">*</span> <span class="n">m</span><span class="p">.</span><span class="nf">step</span> <span class="o">+</span> <span class="n">x</span><span class="p">]);</span> <span class="k">break</span><span class="p">;</span>
               <span class="k">case</span> <span class="nl">CV_64FC1</span><span class="p">:</span>
                   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%6.3f &quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">));</span>    <span class="k">break</span><span class="p">;</span>
           <span class="p">}</span>
       <span class="p">}</span>
       <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">print_array</span><span class="p">(</span><span class="kt">const</span> <span class="kt">double</span><span class="o">*</span> <span class="n">arr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size2</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">if</span><span class="p">(</span> <span class="n">size2</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">){</span>
           <span class="n">printf</span><span class="p">(</span><span class="s">&quot;[%4d] &quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
           <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
               <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%6.3f &quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">size2</span> <span class="o">+</span> <span class="n">j</span><span class="p">]);</span>
           <span class="p">}</span>
           <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
       <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
           <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%6.3f &quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
       <span class="p">}</span>
   <span class="p">}</span>
   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>在迭代了1000次后得到 准确率94.85%， 输出结果：</p>
<div class="highlight"><pre><span></span>999 --------
sum : 10000, sum_right : 9485
[0] [ 980  965]  965    0    0    1    0    2    6    4    2    0
[1] [1135 1114]    0 1114    3    3    0    1    4    2    8    0
[2] [1032  961]   10    3  961    4    8    2    8   13   21    2
[3] [1010  952]    0    0   15  952    1   15    1   10   14    2
[4] [ 982  929]    1    2    3    2  929    1   10    2    6   26
[5] [ 892  822]    6    1    3   23    3  822   13    4   10    7
[6] [ 958  921]   12    3    4    1    5    8  921    0    4    0
[7] [1028  967]    4   10   17    3    8    1    0  967    3   15
[8] [ 974  918]    5    3    5   14    6    8    5    8  918    2
[9] [1009  936]   10    7    1   14   18    7    1    9    6  936
</pre></div>


<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    var location_protocol = (false) ? 'https' : document.location.protocol;
    if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:';
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="http://weibo.com/sdlypyzq">cv_ml_张欣男</a></li>
                            <li><a href="https://www.zhihu.com/people/zhangxinnan">张欣</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a href="http://getpelican.com/">Pelican</a>, which takes great advantage of <a href="http://python.org">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a href="http://coding.smashingmagazine.com/2009/08/04/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>